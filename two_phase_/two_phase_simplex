function out = two_phase_simplex(c, A, b, sense, opts)
% Generic two-phase simplex with GUI tableau browser
% max c*x, s.t. A*x (<=,>=,=) b, x>=0

if nargin < 5, opts = struct; end
opts = defaults(opts);

c = sym(c(:)).';
A = sym(A); b = sym(b(:)); sense = string(sense(:));
[m,n] = size(A);

% Normalize b >= 0
for i=1:m
    if b(i) < 0
        A(i,:) = -A(i,:); b(i) = -b(i);
        if sense(i)=="<=", sense(i)=">=";
        elseif sense(i)==">=", sense(i)="<="; end
    end
end

% Build standard form
varNames = arrayfun(@(k)sprintf('x%d',k),1:n,'uni',0);
S = sym([]); extra = {}; basis = zeros(m,1); art = [];

for i=1:m
    e = sym(zeros(m,1)); e(i)=1;
    switch sense(i)
        case "<="
            S=[S e]; extra{end+1}=sprintf('s%d',i); basis(i)=n+size(S,2);
        case ">="
            S=[S -e]; extra{end+1}=sprintf('u%d',i); % surplus
            S=[S  e]; extra{end+1}=sprintf('a%d',i); basis(i)=n+size(S,2); art(end+1)=basis(i); %#ok<AGROW>
        case "="
            S=[S e];  extra{end+1}=sprintf('a%d',i); basis(i)=n+size(S,2); art(end+1)=basis(i); %#ok<AGROW>
        otherwise
            error('sense entries must be <=, >=, =');
    end
end

Astd = [A S];
names = [varNames extra];
T = [Astd b];

states = struct('T',{},'names',{},'basis',{},'phase',{},'step',{}, ...
                'entering',{},'leaving',{},'ratios',{},'x',{},'z',{});

% Phase I
c1 = sym(zeros(1,size(Astd,2))); c1(art) = -1; % max -sum(art)
T = [T; -c1 0];
T = makeObjectiveConsistent(T, c1, basis);
states = addState(states, T, names, basis, "PHASE I", 0, "", "", [], n, c);

[T,basis,states] = simplexCore(T,basis,c1,names,states,n,c,"PHASE I");

if T(end,end) ~= 0
    error('LP is infeasible (Phase I optimum not zero).');
end

[T,basis] = pivotOutArtificialBasics(T,basis,art);
keep = true(1,size(T,2)-1); keep(art)=false;
T = [T(1:end-1,[keep true]); T(end,[keep true])];
names = names(keep);
basis = remapBasis(basis, keep);

% Phase II
c2 = sym(zeros(1,numel(names))); c2(1:n) = c;
T(end,:) = [-c2 0];
T = makeObjectiveConsistent(T, c2, basis);
states = addState(states, T, names, basis, "PHASE II", 0, "", "", [], n, c);

[T,basis,states] = simplexCore(T,basis,c2,names,states,n,c,"PHASE II");

xAll = extractSolution(T,basis);
out.x = xAll(1:n).';
out.z = T(end,end);
out.tableau = T;
out.basis = basis;
out.varNames = names;
out.states = states;

if opts.launchViewer
    model.A = double(vpa(A(:,1:min(n,2))));
    model.b = double(vpa(b));
    model.sense = sense;
    model.c = double(vpa(c(1:min(n,2))));
    model.n = n;
    simplexViewer(states, model);
end
end

function [T,basis,states] = simplexCore(T,basis,crow,names,states,nOrig,cOrig,phase)
m = size(T,1)-1; n = size(T,2)-1; step=0;
while true
    [mn, enterCol] = min(T(end,1:n));
    if mn >= 0, break; end

    ratios = sym(inf(m,1));
    for i=1:m
        if T(i,enterCol) > 0, ratios(i)=T(i,end)/T(i,enterCol); end
    end
    [th, leaveRow] = min(ratios);
    if isinf(double(vpa(th))), error('Unbounded LP.'); end

    entering = names{enterCol};
    leaving = names{basis(leaveRow)};

    % pivot
    T(leaveRow,:) = T(leaveRow,:)/T(leaveRow,enterCol);
    for r=1:size(T,1)
        if r~=leaveRow, T(r,:) = T(r,:) - T(r,enterCol)*T(leaveRow,:); end
    end
    basis(leaveRow) = enterCol;
    step = step + 1;

    states = addState(states,T,names,basis,phase,step,entering,leaving,ratios,nOrig,cOrig);
end
end

function states = addState(states,T,names,basis,phase,step,entering,leaving,ratios,nOrig,cOrig)
x = extractSolution(T,basis);
xx = zeros(1,min(2,nOrig));
for k=1:numel(xx), xx(k)=double(vpa(x(k))); end
z = 0;
if phase=="PHASE II", z = double(vpa(cOrig(1:nOrig)*x(1:nOrig).')); end
states(end+1) = struct('T',T,'names',{names},'basis',basis,'phase',phase,'step',step, ...
    'entering',string(entering),'leaving',string(leaving),'ratios',ratios,'x',xx,'z',z);
end

function simplexViewer(states, model)
N = numel(states);
labels = arrayfun(@(k)sprintf('%d | %s step %d',k,states(k).phase,states(k).step),1:N,'uni',0);

f = figure('Name','Two-Phase Simplex Viewer','Color','w','Position',[80 80 1500 820]);
ax = axes('Parent',f,'Position',[0.05 0.20 0.42 0.72]);
t = uitable('Parent',f,'Units','normalized','Position',[0.50 0.20 0.47 0.72], ...
    'FontSize',10);
uicontrol(f,'Style','text','String','Tableau:','Units','normalized','Position',[0.05 0.93 0.06 0.04], ...
    'BackgroundColor','w','HorizontalAlignment','left','FontWeight','bold');
popup = uicontrol(f,'Style','popupmenu','String',labels,'Units','normalized','Position',[0.11 0.935 0.28 0.035], ...
    'Callback',@(~,~)render(get(popup,'Value')));
uicontrol(f,'Style','pushbutton','String','Prev','Units','normalized','Position',[0.40 0.935 0.06 0.035], ...
    'Callback',@(~,~)step(-1));
uicontrol(f,'Style','pushbutton','String','Next','Units','normalized','Position',[0.47 0.935 0.06 0.035], ...
    'Callback',@(~,~)step(1));
info = uicontrol(f,'Style','text','Units','normalized','Position',[0.55 0.93 0.42 0.05], ...
    'BackgroundColor','w','HorizontalAlignment','left','FontWeight','bold');

[extPts, poly] = extremePoints2D(model);

render(1);

    function step(d)
        k = get(popup,'Value') + d;
        k = max(1,min(N,k));
        set(popup,'Value',k);
        render(k);
    end

    function render(k)
        s = states(k);
        % Tableau
        [data, rn, cn] = tableauCell(s.T, s.names, s.basis, s.ratios);
        set(t,'Data',data,'RowName',rn,'ColumnName',cn);

        % Info
        txt = sprintf('%s step %d', s.phase, s.step);
        if strlength(s.entering)>0
            txt = sprintf('%s | ENTER: %s | LEAVE: %s', txt, s.entering, s.leaving);
        end
        if s.phase=="PHASE II"
            txt = sprintf('%s | Z = %.6g', txt, s.z);
        end
        set(info,'String',txt);

        % Plot (only for 2D original LP)
        cla(ax); grid(ax,'on'); hold(ax,'on');
        xlabel(ax,'x_1'); ylabel(ax,'x_2'); title(ax,'Feasible region + extreme points + simplex path');
        if model.n == 2
            if ~isempty(poly)
                fill(ax, poly(:,1), poly(:,2), [0.84 0.92 0.98], 'EdgeColor',[0.2 0.45 0.7], 'FaceAlpha',0.40);
            end
            for i=1:size(extPts,1)
                plot(ax, extPts(i,1), extPts(i,2), 'ko','MarkerFaceColor',[0.2 0.2 0.2]);
                text(ax, extPts(i,1), extPts(i,2), sprintf('  E%d (%.3g, %.3g)',i,extPts(i,1),extPts(i,2)), 'FontSize',9);
            end

            path = reshape([states(1:k).x],2,[]).';
            path = path(all(isfinite(path),2),:);
            if ~isempty(path)
                plot(ax, path(:,1), path(:,2), '-o', 'Color',[0.85 0.25 0.1], 'LineWidth',2, 'MarkerSize',5);
                plot(ax, path(end,1), path(end,2), 'ro', 'MarkerSize',9, 'LineWidth',2);
            end

            if s.phase=="PHASE II" && numel(model.c)==2
                z = s.z;
                xx = linspace(min([0;extPts(:,1)])-1, max([1;extPts(:,1)])+1, 250);
                if abs(model.c(2))>1e-12
                    yy = (z - model.c(1)*xx)/model.c(2);
                    plot(ax, xx, yy, 'k--', 'LineWidth',1.5);
                end
            end
            axis(ax,'tight');
            xlim(ax,[max(0,xlim(ax)*[1;0])-1, xlim(ax)*[0;1]+1]);
            ylim(ax,[max(0,ylim(ax)*[1;0])-1, ylim(ax)*[0;1]+1]);
        else
            text(ax,0.1,0.5,'Plot available for 2-variable LPs only','FontSize',11);
            axis(ax,[0 1 0 1]);
        end
        drawnow;
    end
end

function [data,rn,cn] = tableauCell(T,names,basis,ratios)
m = size(T,1)-1;
rn = cell(m+1,1);
for i=1:m, rn{i}=sprintf('R%d (%s)',i,names{basis(i)}); end
rn{m+1}='Rz';
cn = [names {'rhs','ratio'}];
data = cell(size(T,1), size(T,2)+1);
for i=1:size(T,1)
    for j=1:size(T,2), data{i,j}=char(T(i,j)); end
end
for i=1:m
    if isempty(ratios) || isinf(double(vpa(ratios(i)))), data{i,end}='inf';
    else, data{i,end}=char(ratios(i)); end
end
data{m+1,end}='-';
end

function [E,P] = extremePoints2D(model)
if model.n ~= 2, E=[]; P=[]; return; end
A = model.A; b = model.b; s = model.sense;
L = [A b; 1 0 0; 0 1 0];
cand = [];
for i=1:size(L,1)
    for j=i+1:size(L,1)
        M=L([i j],1:2); d=L([i j],3);
        if abs(det(M))<1e-12, continue; end
        x = M\d; cand(end+1,:)=x.'; %#ok<AGROW>
    end
end
E = [];
for k=1:size(cand,1)
    x = cand(k,:).';
    if x(1)<-1e-9 || x(2)<-1e-9, continue; end
    ok=true;
    for i=1:size(A,1)
        lhs=A(i,:)*x;
        if s(i)=="<=" && lhs>b(i)+1e-9, ok=false; break; end
        if s(i)==">=" && lhs<b(i)-1e-9, ok=false; break; end
        if s(i)=="="  && abs(lhs-b(i))>1e-9, ok=false; break; end
    end
    if ok, E(end+1,:)=x.'; end %#ok<AGROW>
end
if isempty(E), P=[]; return; end
E = unique(round(E,10),'rows');
if size(E,1)>=3
    K = convhull(E(:,1),E(:,2)); P = E(K,:);
else
    P = E;
end
end

function T = makeObjectiveConsistent(T, c, basis)
for i=1:numel(basis)
    cb = c(basis(i));
    if cb~=0, T(end,:) = T(end,:) + cb*T(i,:); end
end
end

function x = extractSolution(T,basis)
n = size(T,2)-1; x = sym(zeros(1,n));
for i=1:numel(basis), x(basis(i)) = T(i,end); end
end

function [T,basis] = pivotOutArtificialBasics(T,basis,art)
m = size(T,1)-1; n = size(T,2)-1;
for i=1:m
    if any(basis(i)==art)
        for j=1:n
            if ~any(j==art) && T(i,j)~=0
                T(i,:) = T(i,:)/T(i,j);
                for r=1:size(T,1)
                    if r~=i, T(r,:) = T(r,:) - T(r,j)*T(i,:); end
                end
                basis(i)=j; break;
            end
        end
    end
end
end

function basis = remapBasis(basis, keep)
map = zeros(1,numel(keep)); map(keep)=1:nnz(keep);
for i=1:numel(basis), basis(i)=map(basis(i)); end
end

function opts = defaults(opts)
if ~isfield(opts,'launchViewer'), opts.launchViewer = true; end
end
